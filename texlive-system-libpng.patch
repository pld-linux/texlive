--- texlive-20080816-source/texk/web2c/luatexdir/image/image.h.orig	2008-04-28 10:45:24.000000000 +0200
+++ texlive-20080816-source/texk/web2c/luatexdir/image/image.h	2016-07-23 18:18:25.545919882 +0200
@@ -22,7 +22,7 @@
 #ifndef IMAGE_H
 #  define IMAGE_H
 
-#  include <../libpng/png.h>
+#  include <png.h>
 
 #  define JPG_UINT16      unsigned int
 #  define JPG_UINT32      unsigned long
--- texlive-20080816-source/texk/web2c/luatexdir/image/writepng.c.orig	2008-04-28 10:45:24.000000000 +0200
+++ texlive-20080816-source/texk/web2c/luatexdir/image/writepng.c	2016-07-24 08:43:25.776117469 +0200
@@ -59,7 +59,7 @@
     if ((info_p = png_create_info_struct(png_p)) == NULL)
         pdftex_fail("libpng: png_create_info_struct() failed");
     img_png_info_ptr(idict) = info_p;
-    if (setjmp(png_p->jmpbuf))
+    if (png_jmpbuf(png_p))
         pdftex_fail("libpng: internal error");
     png_init_io(png_p, img_file(idict));
     png_read_info(png_p, info_p);
@@ -68,12 +68,12 @@
         png_set_tRNS_to_alpha(png_p);
     }
     /* alpha channel support  */
-    if (fixed_pdf_minor_version < 4 && png_p->color_type | PNG_COLOR_MASK_ALPHA)
+    if (fixed_pdf_minor_version < 4 && png_get_color_type(png_p, info_p) & PNG_COLOR_MASK_ALPHA)
         png_set_strip_alpha(png_p);
     /* 16bit depth support */
     if (fixed_pdf_minor_version < 5)
         fixed_image_hicolor = 0;
-    if (info_p->bit_depth == 16 && !fixed_image_hicolor)
+    if (png_get_bit_depth(png_p, info_p) == 16 && !fixed_image_hicolor)
         png_set_strip_16(png_p);
     /* gamma support */
     if (fixed_image_apply_gamma) {
@@ -86,15 +86,15 @@
     /* reset structure */
     png_read_update_info(png_p, info_p);
     /* resolution support */
-    img_xsize(idict) = info_p->width;
-    img_ysize(idict) = info_p->height;
-    if (info_p->valid & PNG_INFO_pHYs) {
+    img_xsize(idict) = png_get_image_width(png_p, info_p);
+    img_ysize(idict) = png_get_image_height(png_p, info_p);
+    if (png_get_valid(png_p, info_p, PNG_INFO_pHYs)) {
         img_xres(idict) =
             round(0.0254 * png_get_x_pixels_per_meter(png_p, info_p));
         img_yres(idict) =
             round(0.0254 * png_get_y_pixels_per_meter(png_p, info_p));
     }
-    switch (info_p->color_type) {
+    switch (png_get_color_type(png_p, info_p)) {
     case PNG_COLOR_TYPE_PALETTE:
         img_color(idict) = IMAGE_COLOR_C | IMAGE_COLOR_I;
         break;
@@ -107,9 +107,9 @@
         img_color(idict) = IMAGE_COLOR_C;
         break;
     default:
-        pdftex_fail("unsupported type of color_type <%i>", info_p->color_type);
+        pdftex_fail("unsupported type of color_type <%i>", png_get_color_type(png_p, info_p));
     }
-    img_colordepth(idict) = info_p->bit_depth;
+    img_colordepth(idict) = png_get_bit_depth(png_p, info_p);
     if (readtype == IMG_CLOSEINBETWEEN)
         close_and_cleanup_png(idict);
 }
@@ -134,10 +134,10 @@
 #define write_simple_pixel(r)    pdf_buf[pdf_ptr++] = *r++
 
 #define write_noninterlaced(outmac)                      \
-  for (i = 0; (unsigned) i < (int)info_p->height; i++) { \
+  for (i = 0; (unsigned) i < (int)height; i++) {         \
     png_read_row(png_p, row, NULL);                      \
     r = row;                                             \
-    k = info_p->rowbytes;                                \
+    k = rowbytes;                                        \
     while(k > 0) {                                       \
 	l = (k > pdf_buf_size)? pdf_buf_size : k;        \
 		pdfroom(l);                              \
@@ -149,9 +149,9 @@
         }
 
 #define write_interlaced(outmac)                         \
-  for (i = 0; (unsigned) i < (int)info_p->height; i++) { \
+  for (i = 0; (unsigned) i < (int)height; i++) {         \
             row = rows[i];                               \
-	    k = info_p->rowbytes;                        \
+	    k = rowbytes;                                \
 	    while(k > 0) {                               \
 		l = (k > pdf_buf_size)? pdf_buf_size : k;\
 		pdfroom(l);                              \
@@ -173,36 +173,46 @@
     if (img_colorspace(idict) != 0) {
         pdf_printf("%i 0 R\n", (int) img_colorspace(idict));
     } else {
+	png_colorp palette;
+	int num_palette;
         pdf_create_obj(0, 0);
         palette_objnum = obj_ptr;
+	png_get_PLTE(png_p, info_p, &palette, &num_palette);
         pdf_printf("[/Indexed /DeviceRGB %i %i 0 R]\n",
-                   (int) (info_p->num_palette - 1), (int) palette_objnum);
+                   (int) (num_palette - 1), (int) palette_objnum);
     }
     pdf_begin_stream();
-    if (info_p->interlace_type == PNG_INTERLACE_NONE) {
-        row = xtalloc(info_p->rowbytes, png_byte);
+    if (png_get_interlace_type(png_p, info_p) == PNG_INTERLACE_NONE) {
+        png_uint_32 height = png_get_image_height(png_p, info_p);
+	png_size_t rowbytes = png_get_rowbytes(png_p, info_p);
+        row = xtalloc(rowbytes, png_byte);
         write_noninterlaced(write_simple_pixel(r));
         xfree(row);
     } else {
-        if (info_p->height * info_p->rowbytes >= 10240000L)
+        png_uint_32 height = png_get_image_height(png_p, info_p);
+	png_size_t rowbytes = png_get_rowbytes(png_p, info_p);
+        if (height * rowbytes >= 10240000L)
             pdftex_warn
                 ("large interlaced PNG might cause out of memory (use non-interlaced PNG to fix this)");
-        rows = xtalloc(info_p->height, png_bytep);
-        for (i = 0; (unsigned) i < info_p->height; i++)
-            rows[i] = xtalloc(info_p->rowbytes, png_byte);
+        rows = xtalloc(height, png_bytep);
+        for (i = 0; (unsigned) i < height; i++)
+            rows[i] = xtalloc(rowbytes, png_byte);
         png_read_image(png_p, rows);
         write_interlaced(write_simple_pixel(row));
         xfree(rows);
     }
     pdf_end_stream();
     if (palette_objnum > 0) {
+        png_colorp palette;
+	int num_palette;
+	png_get_PLTE(png_p, info_p, &palette, &num_palette);
         pdf_begin_dict(palette_objnum, 0);
         pdf_begin_stream();
-        for (i = 0; (unsigned) i < info_p->num_palette; i++) {
+        for (i = 0; (unsigned) i < num_palette; i++) {
             pdfroom(3);
-            pdf_buf[pdf_ptr++] = info_p->palette[i].red;
-            pdf_buf[pdf_ptr++] = info_p->palette[i].green;
-            pdf_buf[pdf_ptr++] = info_p->palette[i].blue;
+            pdf_buf[pdf_ptr++] = palette[i].red;
+            pdf_buf[pdf_ptr++] = palette[i].green;
+            pdf_buf[pdf_ptr++] = palette[i].blue;
         }
         pdf_end_stream();
     }
@@ -220,17 +230,21 @@
         pdf_puts("/DeviceGray\n");
     }
     pdf_begin_stream();
-    if (info_p->interlace_type == PNG_INTERLACE_NONE) {
-        row = xtalloc(info_p->rowbytes, png_byte);
+    if (png_get_interlace_type(png_p, info_p) == PNG_INTERLACE_NONE) {
+        png_uint_32 height = png_get_image_height(png_p, info_p);
+	png_size_t rowbytes = png_get_rowbytes(png_p, info_p);
+        row = xtalloc(rowbytes, png_byte);
         write_noninterlaced(write_simple_pixel(r));
         xfree(row);
     } else {
-        if (info_p->height * info_p->rowbytes >= 10240000L)
+        png_uint_32 height = png_get_image_height(png_p, info_p);
+	png_size_t rowbytes = png_get_rowbytes(png_p, info_p);
+        if (height * rowbytes >= 10240000L)
             pdftex_warn
                 ("large interlaced PNG might cause out of memory (use non-interlaced PNG to fix this)");
-        rows = xtalloc(info_p->height, png_bytep);
-        for (i = 0; (unsigned) i < info_p->height; i++)
-            rows[i] = xtalloc(info_p->rowbytes, png_byte);
+        rows = xtalloc(height, png_bytep);
+        for (i = 0; (unsigned) i < height; i++)
+            rows[i] = xtalloc(rowbytes, png_byte);
         png_read_image(png_p, rows);
         write_interlaced(write_simple_pixel(row));
         xfree(rows);
@@ -257,26 +271,30 @@
     pdf_create_obj(0, 0);
     smask_objnum = obj_ptr;
     pdf_printf("/SMask %i 0 R\n", (int) smask_objnum);
-    smask_size = (info_p->rowbytes / 2) * info_p->height;
+    smask_size = (png_get_rowbytes(png_p, info_p) / 2) * png_get_image_height(png_p, info_p);
     smask = xtalloc(smask_size, png_byte);
     pdf_begin_stream();
-    if (info_p->interlace_type == PNG_INTERLACE_NONE) {
-        row = xtalloc(info_p->rowbytes, png_byte);
-        if ((info_p->bit_depth == 16) && fixed_image_hicolor) {
+    if (png_get_interlace_type(png_p, info_p) == PNG_INTERLACE_NONE) {
+        png_uint_32 height = png_get_image_height(png_p, info_p);
+	png_size_t rowbytes = png_get_rowbytes(png_p, info_p);
+        row = xtalloc(rowbytes, png_byte);
+        if ((png_get_bit_depth(png_p, info_p) == 16) && fixed_image_hicolor) {
             write_noninterlaced(write_gray_pixel_16(r));
         } else {
             write_noninterlaced(write_gray_pixel_8(r));
         }
         xfree(row);
     } else {
-        if (info_p->height * info_p->rowbytes >= 10240000L)
+        png_uint_32 height = png_get_image_height(png_p, info_p);
+	png_size_t rowbytes = png_get_rowbytes(png_p, info_p);
+        if (height * rowbytes >= 10240000L)
             pdftex_warn
                 ("large interlaced PNG might cause out of memory (use non-interlaced PNG to fix this)");
-        rows = xtalloc(info_p->height, png_bytep);
-        for (i = 0; (unsigned) i < info_p->height; i++)
-            rows[i] = xtalloc(info_p->rowbytes, png_byte);
+        rows = xtalloc(height, png_bytep);
+        for (i = 0; (unsigned) i < height; i++)
+            rows[i] = xtalloc(rowbytes, png_byte);
         png_read_image(png_p, rows);
-        if ((info_p->bit_depth == 16) && fixed_image_hicolor) {
+        if ((png_get_bit_depth(png_p, info_p) == 16) && fixed_image_hicolor) {
             write_interlaced(write_gray_pixel_16(row));
         } else {
             write_interlaced(write_gray_pixel_8(row));
@@ -286,14 +304,14 @@
     pdf_end_stream();
     pdf_flush();
     /* now write the Smask object */
-    bitdepth = (int) info_p->bit_depth;
+    bitdepth = (int) png_get_bit_depth(png_p, info_p);
     pdf_begin_dict(smask_objnum, 0);
     pdf_puts("/Type /XObject\n/Subtype /Image\n");
     if (img_attr(idict) != NULL && strlen(img_attr(idict)) > 0)
         pdf_printf("%s\n", img_attr(idict));
     pdf_printf("/Width %i\n/Height %i\n/BitsPerComponent %i\n",
-               (int) info_p->width,
-               (int) info_p->height, (bitdepth == 16 ? 8 : bitdepth));
+               (int) png_get_image_width(png_p, info_p),
+               (int) png_get_image_height(png_p, info_p), (bitdepth == 16 ? 8 : bitdepth));
     pdf_puts("/ColorSpace /DeviceGray\n");
     pdf_begin_stream();
     for (i = 0; i < smask_size; i++) {
@@ -319,17 +337,21 @@
         pdf_puts("/DeviceRGB\n");
     }
     pdf_begin_stream();
-    if (info_p->interlace_type == PNG_INTERLACE_NONE) {
-        row = xtalloc(info_p->rowbytes, png_byte);
+    if (png_get_interlace_type(png_p, info_p) == PNG_INTERLACE_NONE) {
+        png_uint_32 height = png_get_image_height(png_p, info_p);
+	png_size_t rowbytes = png_get_rowbytes(png_p, info_p);
+        row = xtalloc(rowbytes, png_byte);
         write_noninterlaced(write_simple_pixel(r));
         xfree(row);
     } else {
-        if (info_p->height * info_p->rowbytes >= 10240000L)
+        png_uint_32 height = png_get_image_height(png_p, info_p);
+	png_size_t rowbytes = png_get_rowbytes(png_p, info_p);
+        if (height * rowbytes >= 10240000L)
             pdftex_warn
                 ("large interlaced PNG might cause out of memory (use non-interlaced PNG to fix this)");
-        rows = xtalloc(info_p->height, png_bytep);
-        for (i = 0; (unsigned) i < info_p->height; i++)
-            rows[i] = xtalloc(info_p->rowbytes, png_byte);
+        rows = xtalloc(height, png_bytep);
+        for (i = 0; (unsigned) i < height; i++)
+            rows[i] = xtalloc(rowbytes, png_byte);
         png_read_image(png_p, rows);
         write_interlaced(write_simple_pixel(row));
         xfree(rows);
@@ -356,26 +378,30 @@
     pdf_create_obj(0, 0);
     smask_objnum = obj_ptr;
     pdf_printf("/SMask %i 0 R\n", (int) smask_objnum);
-    smask_size = (info_p->rowbytes / 2) * info_p->height;
+    smask_size = (png_get_rowbytes(png_p, info_p) / 2) * png_get_image_height(png_p, info_p);
     smask = xtalloc(smask_size, png_byte);
     pdf_begin_stream();
-    if (info_p->interlace_type == PNG_INTERLACE_NONE) {
-        row = xtalloc(info_p->rowbytes, png_byte);
-        if ((info_p->bit_depth == 16) && fixed_image_hicolor) {
+    if (png_get_interlace_type(png_p, info_p) == PNG_INTERLACE_NONE) {
+        png_uint_32 height = png_get_image_height(png_p, info_p);
+	png_size_t rowbytes = png_get_rowbytes(png_p, info_p);
+        row = xtalloc(rowbytes, png_byte);
+        if ((png_get_bit_depth(png_p, info_p) == 16) && fixed_image_hicolor) {
             write_noninterlaced(write_rgb_pixel_16(r));
         } else {
             write_noninterlaced(write_rgb_pixel_8(r));
         }
         xfree(row);
     } else {
-        if (info_p->height * info_p->rowbytes >= 10240000L)
+        png_uint_32 height = png_get_image_height(png_p, info_p);
+	png_size_t rowbytes = png_get_rowbytes(png_p, info_p);
+        if (height * rowbytes >= 10240000L)
             pdftex_warn
                 ("large interlaced PNG might cause out of memory (use non-interlaced PNG to fix this)");
-        rows = xtalloc(info_p->height, png_bytep);
-        for (i = 0; (unsigned) i < info_p->height; i++)
-            rows[i] = xtalloc(info_p->rowbytes, png_byte);
+        rows = xtalloc(height, png_bytep);
+        for (i = 0; (unsigned) i < height; i++)
+            rows[i] = xtalloc(rowbytes, png_byte);
         png_read_image(png_p, rows);
-        if ((info_p->bit_depth == 16) && fixed_image_hicolor) {
+        if ((png_get_bit_depth(png_p, info_p) == 16) && fixed_image_hicolor) {
             write_interlaced(write_rgb_pixel_16(row));
         } else {
             write_interlaced(write_rgb_pixel_8(row));
@@ -386,14 +412,14 @@
     pdf_flush();
     /* now write the Smask object */
     if (smask_objnum > 0) {
-        bitdepth = (int) info_p->bit_depth;
+        bitdepth = (int) png_get_bit_depth(png_p, info_p);
         pdf_begin_dict(smask_objnum, 0);
         pdf_puts("/Type /XObject\n/Subtype /Image\n");
         if (img_attr(idict) != NULL)
             pdf_printf("%s\n", img_attr(idict));
         pdf_printf("/Width %i\n/Height %i\n/BitsPerComponent %i\n",
-                   (int) info_p->width,
-                   (int) info_p->height, (bitdepth == 16 ? 8 : bitdepth));
+                   (int) png_get_image_width(png_p, info_p),
+                   (int) png_get_image_height(png_p, info_p), (bitdepth == 16 ? 8 : bitdepth));
         pdf_puts("/ColorSpace /DeviceGray\n");
         pdf_begin_stream();
         for (i = 0; i < smask_size; i++) {
@@ -442,7 +468,7 @@
     assert(idict != NULL);
     png_p = img_png_png_ptr(idict);
     info_p = img_png_info_ptr(idict);
-    fp = (FILE *) png_p->io_ptr;
+    fp = (FILE *) png_get_io_ptr(png_p);
     /* 1st pass to find overall stream /Length */
     if (fseek(fp, 8, SEEK_SET) != 0)
         pdftex_fail("writepng: fseek in PNG file failed");
@@ -463,9 +489,9 @@
     pdf_printf("/Length %d\n", streamlength);
     pdf_printf("/Filter /FlateDecode\n");
     pdf_printf("/DecodeParms << ");
-    pdf_printf("/Colors %d ", info_p->color_type == 2 ? 3 : 1);
-    pdf_printf("/Columns %d ", (int) info_p->width);
-    pdf_printf("/BitsPerComponent %i ", (int) info_p->bit_depth);
+    pdf_printf("/Colors %d ", png_get_color_type(png_p, info_p) == PNG_COLOR_TYPE_RGB ? 3 : 1);
+    pdf_printf("/Columns %d ", (int) png_get_image_width(png_p, info_p));
+    pdf_printf("/BitsPerComponent %i ", (int) png_get_bit_depth(png_p, info_p));
     pdf_printf("/Predictor %d ", 10);   /* actual predictor defined on line basis */
     pdf_printf(">>\n>>\nstream\n");
     /* 2nd pass to copy data */
@@ -535,8 +561,8 @@
     if (img_attr(idict) != NULL && strlen(img_attr(idict)) > 0)
         pdf_printf("%s\n", img_attr(idict));
     pdf_printf("/Width %i\n/Height %i\n/BitsPerComponent %i\n",
-               (int) info_p->width,
-               (int) info_p->height, (int) info_p->bit_depth);
+               (int) png_get_image_width(png_p, info_p),
+               (int) png_get_image_height(png_p, info_p), (int) png_get_bit_depth(png_p, info_p));
     pdf_puts("/ColorSpace ");
     checked_gamma = 1.0;
     if (fixed_image_apply_gamma) {
@@ -549,22 +575,27 @@
     }
     /* the switching between |info_p| and |png_p| queries has been trial and error. 
      */
-    if (fixed_pdf_minor_version > 1 && info_p->interlace_type == PNG_INTERLACE_NONE && (png_p->transformations == 0 || png_p->transformations == 0x2000)        /* gamma */
-        &&!(png_p->color_type == PNG_COLOR_TYPE_GRAY_ALPHA ||
-            png_p->color_type == PNG_COLOR_TYPE_RGB_ALPHA)
-        && (fixed_image_hicolor || (png_p->bit_depth <= 8))
+    if (fixed_pdf_minor_version > 1 && png_get_interlace_type(png_p, info_p) == PNG_INTERLACE_NONE /* && (png_p->transformations == PNG_TRANSFORM_IDENTITY || png_p->transformations == PNG_TRANSFORM_GRAY_TO_PNG) */        /* gamma */
+        &&!(png_get_color_type(png_p, info_p) == PNG_COLOR_TYPE_GRAY_ALPHA ||
+            png_get_color_type(png_p, info_p) == PNG_COLOR_TYPE_RGB_ALPHA)
+        && (fixed_image_hicolor || (png_get_bit_depth(png_p, info_p) <= 8))
         && (checked_gamma <= 1.01 && checked_gamma > 0.99)
         ) {
         if (img_colorspace(idict) != 0) {
             pdf_printf("%i 0 R\n", (int) img_colorspace(idict));
         } else {
-            switch (info_p->color_type) {
+            switch (png_get_color_type(png_p, info_p)) {
             case PNG_COLOR_TYPE_PALETTE:
+	        {
+		png_colorp palette;
+		int num_palette;
+		png_get_PLTE(png_p, info_p, &palette, &num_palette);
                 pdf_create_obj(0, 0);
                 palette_objnum = obj_ptr;
                 pdf_printf("[/Indexed /DeviceRGB %i %i 0 R]\n",
-                           (int) (info_p->num_palette - 1),
+                           (int) (num_palette - 1),
                            (int) palette_objnum);
+		}
                 break;
             case PNG_COLOR_TYPE_GRAY:
                 pdf_puts("/DeviceGray\n");
@@ -577,13 +608,16 @@
             tex_printf(" (PNG copy)");
         copy_png(idict);
         if (palette_objnum > 0) {
+	    png_colorp palette;
+	    int num_palette;
+	    png_get_PLTE(png_p, info_p, &palette, &num_palette);
             pdf_begin_dict(palette_objnum, 0);
             pdf_begin_stream();
-            for (i = 0; (unsigned) i < info_p->num_palette; i++) {
+            for (i = 0; (unsigned) i < num_palette; i++) {
                 pdfroom(3);
-                pdf_buf[pdf_ptr++] = info_p->palette[i].red;
-                pdf_buf[pdf_ptr++] = info_p->palette[i].green;
-                pdf_buf[pdf_ptr++] = info_p->palette[i].blue;
+                pdf_buf[pdf_ptr++] = palette[i].red;
+                pdf_buf[pdf_ptr++] = palette[i].green;
+                pdf_buf[pdf_ptr++] = palette[i].blue;
             }
             pdf_end_stream();
         }
@@ -593,22 +627,22 @@
             if (fixed_image_apply_gamma &&
                 (checked_gamma > 1.01 || checked_gamma < 0.99))
                 tex_printf("gamma delta=%lf ", checked_gamma);
-            if (png_p->transformations != PNG_TRANSFORM_IDENTITY)
-                tex_printf("transform=%lu", (long) png_p->transformations);
-            if ((info_p->color_type != PNG_COLOR_TYPE_GRAY)
-                && (info_p->color_type != PNG_COLOR_TYPE_RGB)
-                && (info_p->color_type != PNG_COLOR_TYPE_PALETTE))
+            /* if (png_p->transformations != PNG_TRANSFORM_IDENTITY)
+                tex_printf("transform=%lu", (long) png_p->transformations); */
+            if ((png_get_color_type(png_p, info_p) != PNG_COLOR_TYPE_GRAY)
+                && (png_get_color_type(png_p, info_p) != PNG_COLOR_TYPE_RGB)
+                && (png_get_color_type(png_p, info_p) != PNG_COLOR_TYPE_PALETTE))
                 tex_printf("colortype ");
             if (fixed_pdf_minor_version <= 1)
                 tex_printf("version=%d ", (int) fixed_pdf_minor_version);
-            if (info_p->interlace_type != PNG_INTERLACE_NONE)
+            if (png_get_interlace_type(png_p, info_p) != PNG_INTERLACE_NONE)
                 tex_printf("interlaced ");
-            if (info_p->bit_depth > 8)
-                tex_printf("bitdepth=%d ", info_p->bit_depth);
+            if (png_get_bit_depth(png_p, info_p) > 8)
+                tex_printf("bitdepth=%d ", png_get_bit_depth(png_p, info_p));
             if (png_get_valid(png_p, info_p, PNG_INFO_tRNS))
                 tex_printf("simple transparancy ");
         }
-        switch (info_p->color_type) {
+        switch (png_get_color_type(png_p, info_p)) {
         case PNG_COLOR_TYPE_PALETTE:
             write_png_palette(idict);
             break;
@@ -632,7 +666,7 @@
             break;
         default:
             pdftex_fail("unsupported type of color_type <%i>",
-                        info_p->color_type);
+                        png_get_color_type(png_p, info_p));
         }
     }
     pdf_flush();
